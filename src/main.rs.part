/* Loads a program and runs it, based on contents of Options. */

mod arg_plus;
mod builtin;
mod execute;
mod macro_;
mod value;

mod options;
mod tokenize;
mod token;
mod loader;
mod pretty;
mod repl;

use std::process::exit;
use std::io::stderr;

use options::ExecutionTarget;
use token::CodeSource;
use loader::LoadLocation;

fn main() {
    fn process_one(target: &ExecutionTarget) {
        let buf = match target {
        	/*
        	val open_in : string -> in_channel
				Open the named file for reading, and return a new input channel on that file, positionned at the beginning of the file.
        	*/
            ExecutionTarget::File (f) =>
            	tokenize::tokenize_channel(CodeSource::File (f), open_in(f)),
            /*
            val stdin : in_channel
				The standard input for the process.
            */
            ExecutionTarget::Stdin =>
            	tokenize::tokenize_channel(CodeSource::Stdin, stdin),
            ExecutionTarget::Literal (s) =>
            	tokenize::tokenize_string(CodeSource::Cmdline, s)
        };
        let location = match target {
            ExecutionTarget::File (f) => loader::location_around(f),
            _ => LoadLocation::Cwd
        };
        /*  */
        unsafe {
		    if options::run.disassemble {
		    	println!(pretty::dump_code_tree_terse(buf));
		    }
		    else if options::run.disassemble_verbose {
		    	println!(pretty::dump_code_tree_dense(buf));
		    }
		    else if options::run.print_package {
		    	println!(loader::package_root_path());
		    }
		    else if options::run.print_project {
		    	println!(loader::project_path_for_location(location));
		    }
		    else {
		    	loader::execute_program_from(location, buf);
		    }
		}
    }
    unsafe {
		if options::run.repl {
			#[cfg(BUILD_INCLUDE_REPL)]
			repl::repl(options::run.targets);
		}
		else {
		    /* FIXME: This is maybe awkward? It is here so printPackage can work without a target. */
		    /* It works by assuming an implicit -e '', which is only safe if we assume */
		    /* option.ml would have failed already if that weren't ok. */
			for target in (match &*options::run.targets { [] => vec![options::Literal ("".to_string())], t => options::run.targets }) {
				match process_one(target) {
					Err (token::CompilationError) => {
						write!(stderr(), "{}", token::error_string(e));
						exit(1);
					},
					Err () => {
						write!(stderr(), "{}", e);
						exit(1);
					},
					Ok (_) => ()
				}
			}
		}
    }
}
