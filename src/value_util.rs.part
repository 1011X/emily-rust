/* This file contains support methods for creating values with certain properties, split out from Value for module recursion reasons. */
#![feature(
	slice_patterns,
	advanced_slice_patterns
)]

#[macro_use]
extern crate lazy_static;

mod value;
mod pretty;
mod options;
mod tokenize;

use std::collections::HashMap;
use value::*;
use token::{
	CodeSource,
	BoxKind
}

/* Misc failure throw methods */
fn badArg(desired: &str, name: &str, var: Value) -> ! {
	panic!("Bad argument to {}: Need {}, got {}", name, desired, pretty::dumpValue(var));
}

fn badArgTable(name: &str, var: Value) -> ! {
	badArg("table", name, var);
}

fn badArgClosure(name: &str, var: Value) -> ! {
	badArg("closure", name, var);
}

fn impossibleArg(name: &str) -> ! {
	panic!("Internal failure: Impossible argument to {}", name);
}


fn misapplyString(a: &Value, b: &Value) -> String {
	format!("Runtime failure: {} can't respond to {}", pretty::dumpValue(a), pretty::dumpValue(b))
}

fn rawMisapplyArg(a: &Value, b: &Value) -> ! {
	panic!(misapplyString(a, b))
}

/* Tools */
fn boolCast(v: bool) -> Value {
	if v { Value::True }
	else { Value::Null }
}

fn ignoreFirst<T, U>(_: T, x: U) -> U { x }

/* Create a closure from an ocaml function */

fn snippetClosure<F>(argCount: usize, exec: F) -> Value
where F: Fn(Vec<Value>) -> Value {
	Value::Closure {
		exec: ClosureExec::Builtin(exec),
		needArgs: argCount,
		bound: vec![],
		this: ClosureThis::ThisNever
	}
}

/* For debugging, call this after creating a hashtable set to become a Value */
fn sealTable(t: TableValue) {
	unsafe {
		if options::run.trackObjects {
			ID_GENERATOR += 1.0;
			t.insert(ID_KEY, Value::FloatValue(ID_GENERATOR));
		}
	}
}

/* Same as calling tableBlank(TrueBlank). We need a separate version because
   tableBlank relies on some of the functions that require tableTrueBlank
   to themselves be defined, and it gets awkward w/mutual recursion. */
fn tableTrueBlank() -> TableValue {
	let t = HashMap::withCapacity(1);
	sealTable(t);
	t
}

fn tableTrueBlankInheriting(v: Value) -> TableValue {
	let t = tableTrueBlank();
	t.insert(PARENT_KEY, v);
	t
}

/* Makes a scope to be used in a snippetTextClosure */
fn snippetScope(bindings: Vec<(String, Value)>) -> Value {
	let scopeTable = tableTrueBlank();
	for (k, v) in bindings {
		scopeTable.insert(Value::AtomValue(k), v);
	}
	Value::TableValue(scopeTable)
}

/* Define an ad hoc function using a literal string inside the interpreter. */
fn snippetTextClosureAbstract(source: CodeSource, thisKind: ClosureThis, context: Vec<(String, Value)>, keys: Vec<String>, text: String) -> Value {
	Value::Closure {
		exec: ClosureExec::User {
			body: tokenize::snippet(source, text),
			envScope: snippetScope(context),
			scoped: false,
			key: keys,
			hasReturn: false
		},
		needArgs: keys.len(),
		bound: vec![],
		thisValue: thisKind
	}
}

/* Define an ad hoc function using a literal string inside the interpreter. */
fn snippetTextClosure(source: CodeSource, context: Vec<(String, Value)>, keys: Vec<String>, text: String) -> Value {
	snippetTextClosureAbstract(source, ClosureThis::ThisNever, context, keys, text)
}

fn snippetTextMethod(source: CodeSource, context: Vec<(String, Value)>, keys: Vec<String>, text: String) -> Value {
	snippetTextClosureAbstract(source, ClosureThis::ThisBlank, context, keys, text)
}

fn snippetApply(closure: Value, val: Value) -> ClosureValue {
	match closure {
		cv @ Value::Closure {bound, needArgs, ..} if needArgs > 1 =>
			Value::Closure {
				bound: bound.clone().push(val),
				needArgs: needArgs - 1,
				.. cv
			},
		_ => panic!("Internal error")
	}
}

/* These first three snippet closures are relied on by the later ones */
lazy_static! {
	/* internal.tern exposes this */
	/* Ternary function without short-circuiting... */
	pub static ref rawTern : Value = snippetClosure(3, |args|
		match &*args {
			[Value::Null, _, v] => v,
			[_, v, _] => v,
			_ => impossibleArg("rawTern")
		}
	);
	
	/* ...used to define the ternary function with short-circuiting: */
	/* This is used by snippets that require tern, but tern in scopePrototype is separate. */
	pub static ref tern = snippetTextClosure(
		CodeSource::Internal("tern".to_string()),
		vec![
			("rawTern", rawTern),
			("null", Value::Null)
		],
		vec!["pred", "a", "b"],
		"(rawTern pred a b) null".to_string()
	);
}

/* This handles what occurs when you assign to a table while defining a new object literal.
   It takes newborn functions and assigns a this to them. (Old functions just freeze.) */
fn rawRethisAssignObjectDefinition(obj: Value, v: Value) -> Value {
	match v {
		c @ Value::Closure {this: ClosureThis::ThisBlank, ..} =>
			Value::Closure {
				this: ClosureThis::CurrentThis(obj, obj),
				.. c
			},
		c @ Value::Closure {this: ClosureThis::CurrentThis(current, this), ..} =>
			Value::Closure {
				this: ClosureThis::FrozenThis(current, this),
				.. c
			},
		_ => v
	}
}

/* This handles what occurs when you assign to a table at any other time:
   The "newborn" quality that makes it possible to assign a `this` is lost. */
fn rawRethisAssignObject(v: Value) -> Value {
	match v {
		c @ Value::Closure {this: ThisBlank, ..} =>
				Value::Closure {
					this: ClosureThis::ThisNever,
					.. c
				},
		c @ Value::Closure {
			this: ClosureThis::CurrentThis(current, this),
			..
			} =>
				Value::Closure {
					this: CurrentThis::FrozenThis(current, this),
					.. c
				},
		_ => v
	}
}

lazy_static! {
	/* Emily versions of the above two */
	pub static ref rethisAssignObjectDefinition : Value = snippetClosure(2, |args|
		match &*args {
			[obj, a] => rawRethisAssignObjectDefinition(obj, a),
			_ => impossibleArg("rethisAssignObjectDefinition")
		}
	);

	pub static ref rethisAssignObject : Value = snippetClosure(1, |args|
		match &*args {
			[a] => rawRethisAssignObject(a),
			_ => impossibleArg("RETHIS_ASSIGN_OBJECT");
		}
	);
}

/* Setup for filter-based functions */
/* FIXME: Remove need for target */
fn actTableSet(target: Value, t: &mut TableValue, key: Value, value: Value) {
	t.insert(key, value);
	if options::run.traceSet {
		println!("Set update {}", pretty::dumpValueNewTable(target);
	}
}

fn actTableSetWith(modifier: F, target: Value, t: TableValue, key: Value, value: Value)
where F: Fn(Value, Value) -> Value {
	actTableSet(target, t, key, modifier(target, value));
}

fn actPairTableSet(t1v: Value, t1: TableValue, t2v: Value, t2: TableValue, key: Value, value: Value) {
	actTableSet(t1v, t1, key, value);
	actTableSet(t2v, t2, key, value);
}

/* This could have been done in-place with a k combinator */
fn rethisAssignObjectInsideLet<T>(_: T, x: Value) -> Value {
	rawRethisAssignObject(x)
}

/* This next batch is the functions required to create a blank user table */

lazy_static! {
	/* Most tables need to be prepopulated with a "has". Here's the has tester for a singular table: */
	pub static ref rawHas : Value = snippetClosure(2, |args|
		match &*args {
			[Value::Table (t), key] |
			[Value::Object (t), key] =>
				boolCast(t.contains_key(key)),
		
			[v, _] => badArgTable("rawHas", v),
			_ => impossibleArg("rawTern")
		}
	);

	/* A curried one which knows how to check the super class: */
	pub static ref hasConstruct : Value = snippetTextClosure(
		CodeSource::Internal("hasConstruct".to_string()),
		vec![
			("rawHas", rawHas),
			("tern", tern),
			("true", Value::True),
			("null", Value::Null)
		],
		vec!["obj", "key"],
		"tern (rawHas obj key) ^(true) ^(\
		     tern (rawHas obj .parent) ^(obj.parent.has key) ^(null)\
		 )".to_string()
	);
}

/* ...And a factory for one with a preset object: */
fn makeHas(obj: Value) -> ClosureValue {
	snippetApply(HAS_CONSTRUCT, obj)
}

lazy_static! {
	/* Most tables need to be prepopulated with a "set". Here's the setter for a singular table: */
	pub static ref rawSet : Value = snippetClosure(3, |args| // TODO: Unify with makeLet?
		match &*args {
			[tv @ Value::Table (t), key, value] |
			[tv @ Value::Object (t), key, value] => {
				actTableSet(tv, t, key, value);
				Value::Null
			},
		
			[v, _, _] => badArgTable("rawSet", v),
			_ => impossibleArg("rawSet")
		}
	);

	/* ...And a factory for a curried one that knows how to check the super class: */
	pub static ref setConstruct : Value = snippetTextClosure(
		CodeSource::Internal("SET_CONSTRUCT"),
		vec![
			("rawHas", rawHas),
			("rawSet", rawSet),
			("tern", tern),
			("true", Value::True),
			("null", Value::Null)
		],
		vec!["obj", "key", "value"],
		"tern (rawHas obj key) ^(rawSet obj key value) ^(\
		     obj.parent.set key value                # Note: Fails in an inelegant way if no parent\
		 )".to_string()
	);
}

fn makeSet(obj: Value) -> ClosureValue {
	snippetApply(SET_CONSTRUCT, obj)
}

lazy_static! {
/* Same thing, but for an ObjectValue instead of a TableValue.
   The difference lies in how "this" is treated */
	pub static ref objectSetConstruct : Value = snippetTextClosure(
		CodeSource::Internal("objectSetConstruct"),
		vec![
			("rawHas", rawHas),
			("rawSet", rawSet),
			("tern", tern),
			("true", Value::True),
			("null", Value::Null),
			("modifier", RETHIS_ASSIGN_OBJECT)
		],
		vec!["obj", "key", "value"],
		"tern (rawHas obj key) ^(rawSet obj key (modifier value)) ^(\
		     obj.parent.set key (modifier value) # Note: Fails in an inelegant way if no parent\
		 )".to_string()
	);
}

fn makeObjectSet(obj: Value) -> ClosureValue {
	snippetApply(OBJECT_SET_CONSTRUCT, obj)
}

/* Many tables need to be prepopulated with a "let". Here's the let setter for a singular table: */
/* TODO: Don't 'make' like this? */
fn makeLet<F>(action: F, target: Value, t: TableValue) -> Value
where F: Fn(Value, Value) {
	snippetClosure(2, |args|
		match &*args {
			[key, value] => {
				action(key, value);
				Value::Null
			},
			_ => impossibleArg("makeLet")
		}
	)
}

/* Helpers for tableBlank */
fn populateWithHas(t: TableValue) {
	tableSetString(t, Value::hasKeyString, makeHas(Value::Table (t))); /* FIXME: Should this ever be ObjectValue...? */
}

fn populateWithSet(t: TableValue) {
	populateWithHas(t);
	tableSetString(t, Value::SET_KEY_STRING, makeSet(Value::Table (t)));
}

/* An object is self-referential, so is more complicated than a simple blank table;
   the table and value must be created together. */
/* table, value convention */
static mut OBJECT_PROTOTYPE_KNOT : Value = Value::Null;

/* Not unified with tableBlank because it returns a value */
fn objectBlank(context: Value) -> Value {
	let obj = tableTrueBlank();
	let objValue = Value::Object (obj);
	populateWithHas(obj);
	tableSetString(obj, value::setKeyString, makeObjectSet(objValue));
	tableSetString(obj, value::letKeyString, makeLet(actTableSetWith, rethisAssignObjectInsideLet, objValue, obj));
	tableSetString(obj, value::PARENT_KEY_STRING, context.object_proto);
	objValue
}

/* FIXME: Once actTableSet no longer takes a table value, the dummy TableValue will not be needed */
fn populateLetForScope(storeIn: TableValue, writeTo: Value) {
	tableSetString(
		storeIn,
		value::LET_KEY_STRING,
		makeLet(
			actTableSet(
				Value::Table (writeTo),
				writeTo
			)
		)
	)
}

/* Give me a simple table of the requested type, prepopulate with basics. */
fn tableBlank(kind: TableValue) -> TableType {
	let t = tableTrueBlank();
	match kind {
		TableBlankKind::TrueBlank => (),
		TableBlankKind::NoSet => populateWithHas(t),
		TableBlankKind::NoLet => populateWithSet(t),
		TableBlankKind::WithLet => {
			populateWithSet(t);
			populateLetForScope(t, t);
		}
	}
	t
}

enum BoxTarget { Package, Object }
type BoxSpec = Populating(BoxTarget, Value);

let boxBlank boxKind boxParent =
    let Populating(targetType,targetValue) = boxKind in
    let t = tableBlank NoLet in
    let privateTable = tableBlank NoLet in
    let privateValue = TableValue privateTable in
    let targetTable = tableFrom targetValue in
    tableSet privateTable Value.letKey (makeLet @@ (* Another fallacious value usage *)
        actPairTableSet privateValue privateTable (TableValue t) t
    );
    tableSet t Value.letKey (makeLet @@ (* See objects.md *)
        if targetType=Package then
            actPairTableSet targetValue targetTable (TableValue t) t
        else
            actTableSetWith rawRethisAssignObjectDefinition targetValue targetTable
    );
    if targetType=Package then
        tableSet t exportLetKey (makeLet @@ actTableSet targetValue targetTable);
    tableSet t thisKey   targetValue;
    tableSet t parentKey boxParent;
    tableSet t currentKey targetValue;
    (* Access to a private value: *)
    tableSet t privateKey privateValue;
    t

fn tableInheriting(tableKind: TableValue, v: Value) -> TableType {
	let mut t = tableBlank(tableKind);
	t.insert(value::PARENT_KEY, v);
	t
}

/* Not used by interpreter, but present for user */
fn rawRethisTransplant(obj: Value) -> Value {
	match obj {
		Value::Closure {..c} => Value::Closure {this: ClosureThis::Blank, ..c},
		_ => obj
	}
}

lazy_static! {
	pub static ref RETHIS_TRANSPLANT : Value = snippetClosure(1, |args|
		match &*args {
			[obj] => rawRethisTransplant(obj),
			_ => impossibleArg("RETHIS_TRANSPLANT")
		}
	);
}

/* Helpers for super function */
fn rawRethisSuperFrom(obj: Value, v: Value) -> Value {
	match v {
		Value::ClosureValue(c @ ClosureValue {
			this: ClosureThis::CurrentThis(current, _),
			..
		}) => {
			let mut cv = c.clone();
			cv.this = ClosureThis::CurrentThis(current, obj);
			Value::ClosureValue(cv)
		},
		_ => v
	}
}

lazy_static! {
	pub static ref RETHIS_SUPER_FROM : Value = snippetClosure(2, |args|
		match &*args {
			[obj, a] => rawRethisSuperFrom(obj, a),
			_ => impossibleArg("RETHIS_SUPER_FROM")
		}
	);

	pub static ref MISAPPLY_ARG : Value = snippetClosure(2, |args|
		match &*args {
			[a, b] => rawMisapplyArg(a, b),
			_ => impossibleArg("MISAPPLY_ARG")
		}
	);

	/* Factory for super functions */
	pub static ref SUPER_CONSTRUCT : Value = snippetTextClosure(
		CodeSource::Internal("SUPER_CONSTRUCT"),
		vec![
			("rethis", RETHIS_SUPER_FROM),
			("rawHas", RAW_HAS),
			("tern", TERN),
			("misapplyArg", MISAPPLY_ARG)
		],
		vec!["callCurrent", "obj", "arg"],
		"tern (rawHas callCurrent .parent) ^(rethis obj (callCurrent.parent arg)) ^(misapplyArg obj arg)"
	);
}

fn makeSuper(current: Value, this: Value) -> ClosureValue {
	snippetApply(Value::ClosureValue(snippetApply(SUPER_CONSTRUCT, current)), this)
}

fn stackString(stack: ExecuteStack) -> String {
	let mut result = "Stack:".to_string();
	for frame in stack.iter().rev() {
		result.push_str("\n\t");
		result.push_str(&(match frame {
			ExecuteFrame {register: RegisterState::LineStart (..), ref code, .. }
			if !code.isEmpty() && !code[0].isEmpty() =>
				token::positionString(&code[0][0].at),
			ExecuteFrame {register: RegisterState::FirstValue (_, _, ref at), ..} |
			ExecuteFrame {register: RegisterState::PairValue (_, _, _, ref at), ..} =>
				token::positionString(at),
			ExecuteFrame {ref code, ..} if code.isEmpty() => "<empty file>".to_string(),
			ExecuteFrame {ref code, ..} if code[0].isEmpty() => "<lost place>".to_string()
		}));
	}
	result
}

fn rawMisapplyStack(stack: ExecuteStack, a: &Value, b: &Value) -> Result<(), String> {
	Err(format!("{}\n{}", misapplyString(a, b), stackString(stack)))
}

fn makeLazy<F>(table: TableValue, key: Value, func: F) -> Value
where F: Fn() -> Value {
	Value::BuiltinUnaryMethodValue (move |_| { /* Later maybe pass on this to func? */
		let result = func();
		table.insert(key, result);
		result
	})
}

fn tableSetLazy<F>(table: TableValue, key: Value, func: F) -> Value
where F: Fn() -> Value {
	tableSet(table, key, makeLazy(table, key, func));
}

