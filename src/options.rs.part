/* Parse and validate command line arguments. */

static VERSION : &str = "0.2";
static FULL_VERSION : &str = "Emily language interpreter: Version 0.2";

enum ExecutionTarget { Stdin, File(String), Literal(String) }

struct OptionSpec {
    /* Execution args */
    targets : Vec<ExecutionTarget>,
    repl : bool,
    step_macro : bool,
    trace : bool,
    track_objects : bool,
    trace_set : bool,
    package_path : Option<String>,
    project_path : Option<String>,
    dont_need_targets : bool, /* Set indirectly by several options */

    /* Things to do instead of execution */
    disassemble : bool,
    disassemble_verbose : bool,
    print_package : bool,
    print_project : bool,
    print_version : bool,
    print_machine_version : bool
}

static mut run : OptionSpec = OptionSpec {
    targets: Vec::new(),
    repl: false,
    step_macro: false, trace: false, track_objects: false, trace_set: false,
    package_path: None, project_path: None,
    disassemble: false, disassemble_verbose: false,
    print_version: false, print_machine_version: false
};

/* Quarantined
static key_mutate_argument    = arg_plus::key_mutate(|l| format!("--{}", l.connect("-")));
static key_mutate_environment = arg_plus::key_mutate(|l|
	format!("EMILY_{}", l.iter().map(|s| s.to_uppercase()).collect::<Vec<_>>().connect("_"))
);
)
*/

fn build_path_set_spec<F>(name, action: F, whatIs: String) -> (, Spec, String)
	where F: Fn(String) {
    (name, Spec::String(action), format!("Directory root for packages loaded from \"{}\"", whatIs))
}

fn init() {
    let mut targets = vec![];
    let mut seenStdin = false;

    let usage = fullVersion.to_string() + "

Sample usage:
    emily filename.em     # Execute program
    emily -               # Execute from stdin
    emily -e \"println 3\"  # Execute from command line
    emily -i              # Run in interactive mode (REPL)
    emily -i filename.em  # ...after executing this program"

/* Only include this bit if REPL enabled */
+ if cfg!(BUILD_INCLUDE_REPL) { "
    emily -i              # Run in interactive mode (REPL)
    emily -i filename.em  # ...after executing this program"
else { "" } + "

Options:";

    let version_spec = |key|
    	(key, Arg.Unit(|| run.print_version = true), "Print interpreter version");

    let executeArgs = vec![ /* Basic arguments */
        ("-", Arg.Unit(|| /* Arg's parser means the magic - argument must be passed in this way. */
            if !seenStdin {
            	Err ("Attempted to parse stdin twice; that doesn't make sense?")
            }
            else {
            	seenStdin = true;
            	targets.push(ExecutionTarget::Stdin);
            	Ok(())
            }
        ), ""), /* No summary, this shouldn't be listed with options. */

        /* Args */
        ("-e", Arg.String(|f| {
            targets.push(ExecutionTarget::Literal (f));
            Ok(())
        }), "Execute code inline")
    ];
    
    if cfg!(BUILD_INCLUDE_REPL) {
		executeArgs.push(
		    ("-i", Arg.Unit(|f| {
		        run.repl = true;
		        /* targets.push(ExecutionTarget::Repl); */
		        Ok(())
		    }), "Enter interactive mode (REPL)")
		);
	}
	
	executeArgs.push_all(&[
	    version_spec("-v"),
	    version_spec("--version"),

	    ("--machine-version", Arg.Unit(|| {
	    	run.print_machine_version = true;
	    	Ok(())
	    }), "Print interpreter version (machine-readable-- number only)")
	]);

    let environment_args = vec![ /* "Config" arguments which can be also set with env vars */
        build_path_set_spec(["package", "path"], |a| run.package_path = Some (a), "package"),
        build_path_set_spec(["project", "path"], |a| run.project_path = Some (a), "project")
    ];

    let debug_args = vec![ /* For supporting Emily development itself-- separate out to sort last in help */
        ("--debug-dis", Arg.Unit(|| run.disassemble = true), "Print \"disassembled\" code and exit"),
        ("--debug-disv", Arg.Unit(|| run.disassemble_verbose = true), "Print \"disassembled\" code with position data and exit"),
        ("--debug-macro", Arg.Unit(|| run.step_macro = true), "Print results of each individual macro evaluation"),
        ("--debug-trace", Arg.Unit(|| run.trace = true), "When executing, print interpreter state"),
        ("--debug-track", Arg.Unit(|| run.track_objects = true), "When executing, give all objects a unique \"!id\" member"),
        ("--debug-set", Arg.Unit(|| run.trace_set = true), "When executing, print object contents on each set"),
        ("--debug-run", Arg.Unit(|| {
            run.trace = true;
            run.track_objects = true;
            run.trace_set = true;
        }),  "When executing, set all runtime trace type options")
    ];

    let args = 
    	executeArgs @ key_mutate_argument(environmentArgs) @ debugArgs;

    let targetParse = |t| targets.push(ExecutionTarget::File (t));

    ArgPlus.envParse(key_mutate_environment(environmentArgs));
    ArgPlus.argParse(args, targetParse, usage, |_|
        /* Arguments are parsed; either short-circuit with an informational message, or store targets */
        if run.print_machine_version {
        	println!(version);
        }
        else if run.print_version {
        	println!(fullVersion);
        }
        else {
            run.targets.reverse();
            if !run.dont_need_targets {
            	if run.targets == [] {
		            return Err (ArgPlus.Help 1) /* No targets! Fail and print help. */
		        }
		    }
        }
    );
}
